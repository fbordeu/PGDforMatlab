%ELEMENT CLASS
%
% This file is subject to the terms and conditions defined in
% file 'LICENSE.txt', which is part of this source code package.
%
% Principal developer : Adrien Leygue (Adrien.Leygue@ec-nantes.fr)
%
classdef ELEMENT < handle
    properties
        %Name used for element ID (SEG_1, QUAD_4,...)
        name = '';
        %Shape of the element (SEG,TRI,...) used for checking the
        %compatibility between element types
        shape = '';
        %dimension of the element (SEG->1, TRI->2,...)
        dim = 0;
        %element number id in gmsh
        gmsh_type = NaN;
        %name used in xdmf export
        xdmf_name = '';
        %xdmf format internal number for this element
        xdmf_type = NaN;
        xdmf_cell_field = false;
        
        %number of shape functions
        Nphi = 0;
        %cell array of strings: name of the coordinates in the parent
        %element
        coords = {};
        %cell array of strings: symbolic form of the shape functions
        phi =  {};
        %coordinates of the nodes associated to the shape functions (Nphixdim)
        nodes = [];
        %cell array describing the sub-elements generated by the element.
        %(one line per sub-element)
        %1st item: name of the sub-element
        %2nd item: connectivity of the sub-element in terms of the nodes of the element
        entities = {};
        %Number of sub-elements
        Nentities =0;
        %vector which associates each shape function to a
        %sub-element/entity zero stands for the element itself
        dof_entities = [];
        %default function handle to get the integration points and weights
        integration_points_fct = [];
        %ALL the quantities below are computes automatically
        
        %Nphi by 1 cell array of function handles to evaluate the shape functions
        %fct_xi = [];
        fct_phi = [];
        %Nphi by dim cell array of functions to evaluate the gradient of the shape
        %functions
        fct_dphidxi= [];
        %Nphi by dim cell array of functions to evaluate the second gradient
        % of the shape functions
        fct_d2phidxideta = [];
        %Neval by Nphi matrix  of the values of the shape functions evaluated at all the
        %integration points
        eval_phi = [];
        %Neval cell array of matrices (dim by Nphi) containing the values of the shape functions gradients evaluated at all the
        %integration points
        eval_dphidxi = {};
        %1 by Neval vector of integration weights
        eval_weights = [];
        %Neval by dim matrix  of integration points coordinates
        eval_xi = [];
        %number of integration points
        Neval = 0;
        %if one the jacobian is constant for this element,...which could be
        %exploited
        const_jac = 0;
        max_derivative = 1;
    end
    methods
        function elem = ELEMENT(el_name,sub)
            %Syntax:
            % elem = ELEMENT(el_name)
            %INPUTS:
            % el_name: a string identifying the element type or a cell
            % array of strings with all the element types.
            % sub: a boolean indicating if the sub-elements are to be
            % generated as well.
            %NB: ALL is a reserved keyword to generate all the elements and
            %write the elements to the file ELEMENT_LIB.mat
            %If a file named ELEMENT_LIB.mat exists the element will be
            %read from that file
            %OUTPUTS
            %NB: if the keyword ALL is used or if sub==true, the elements are sorted by increasing
            % dimensionality
            
            % elem: an array of the requested elements.
            if nargin==0 , return; end
            
            if nargin==1
                sub=false;
            end
            
            if sub
                elem = ELEMENT(el_name,false);
                my_names = {elem.name};
                missing = {};
                for i=1:numel(elem)
                    for j=1:elem(i).Nentities
                        if ~ismember(elem(i).entities{j,1},my_names)
                            missing = [missing elem(i).entities(j,1)]; %#ok<AGROW>
                        end
                    end
                end
                missing = unique(missing);
                if (~isempty(missing))
                    elem = [elem ELEMENT(missing)];
                end
                p = sort_dim(elem);
                elem = elem(p);
                return;
            end
            
            %input checking.
            if iscell(el_name)
                assert(~ismember('ALL',el_name),'ALL cannot be used with a cell array input');
                assert(all(cellfun(@isstr, el_name)),'Input argument should be a string or a cell array of strings');
                assert(isvector(el_name),'Cell array input should be a vector');
                N = numel(el_name);
                elem(N) = ELEMENT();
                for i=1:N
                    elem(i) = ELEMENT(el_name{i});
                end
                return;
            end
            
            if ~strcmpi(el_name,'ALL')
                if ~isempty(dir('ELEMENT_LIB.mat'))
                    load ELEMENT_LIB.mat
                    elem = elem(strcmpi(el_name,{elem.name}));
                    return;
                end
            end
            
            %generate any possible element
            i=1;
            if(strcmpi(el_name,'POINT') || strcmpi(el_name,'ALL'))
                elem(i).name='POINT';
                elem(i).shape='POINT';
                elem(i).dim=0;
                elem(i).gmsh_type = 15;
                elem(i).xdmf_name = 'Polyvertex';
                elem(i).xdmf_type = 1;
                elem(i).xdmf_cell_field = false;
                elem(i).Nphi = 1;
                elem(i).coords = {'xi'};
                elem(i).phi = {'1'};
                elem(i).nodes = 0';
                elem(i).entities = cell(0,2);
                elem(i).dof_entities=0;
                elem(i).const_jac = 1;
                %built-in integration method, can be overridden.
                elem(i).integration_points_fct = @(NP) elem(i).point_points(NP);
                %computation of the additional element properties (symbolic
                %processing)
                elem(i) = PROCESS_ELEMENT(elem(i));
                
                i=i+1;
            end
            if(strcmpi(el_name,'EDGE_1') || strcmpi(el_name,'ALL'))
                elem(i).name='EDGE_1';
                elem(i).shape='EDGE';
                elem(i).dim=1;
                elem(i).gmsh_type = NaN;
                elem(i).xdmf_name = '';
                elem(i).xdmf_type = NaN;
                elem(i).xdmf_cell_field = true;
                elem(i).Nphi = 1;
                elem(i).coords = {'xi'};
                elem(i).phi = {'1'};
                elem(i).nodes = 0;
                elem(i).entities = cell(2,2);
                elem(i).entities(1,:) = {'POINT', 1};
                elem(i).entities(2,:) = {'POINT', 1};
                elem(i).dof_entities=0;
                elem(i).const_jac = 1;
                elem(i).integration_points_fct = @(NP) elem(i).gauss_points(elem(i).dim,NP);
                elem(i) = PROCESS_ELEMENT(elem(i));
                i=i+1;
            end
            if(strcmpi(el_name,'EDGE_2') || strcmpi(el_name,'ALL'))
                elem(i).name='EDGE_2';
                elem(i).shape='EDGE';
                elem(i).dim=1;
                elem(i).gmsh_type = 1;
                elem(i).xdmf_name = 'Polyline';
                elem(i).xdmf_type = 2;
                elem(i).xdmf_cell_field = false;
                elem(i).Nphi = 2;
                elem(i).coords = {'xi'};
                elem(i).phi = {'(1-xi)/2' , '(1+xi)/2'};
                elem(i).nodes = [-1 1]';
                elem(i).entities = cell(2,2);
                elem(i).entities(1,:) = {'POINT', 1};
                elem(i).entities(2,:) = {'POINT', 2};
                elem(i).dof_entities = [1 2];
                elem(i).const_jac = 1;
                elem(i).integration_points_fct = @(NP) elem(i).gauss_points(elem(i).dim,NP);
                elem(i) = PROCESS_ELEMENT(elem(i));
                i = i+1;
            end
            if(strcmpi(el_name,'EDGE_3') || strcmpi(el_name,'ALL'))
                elem(i).name='EDGE_3';
                elem(i).shape='EDGE';
                elem(i).dim=1;
                elem(i).xdmf_name = 'EDGE_3';
                elem(i).xdmf_type = 34;
                elem(i).xdmf_cell_field = false;
                elem(i).gmsh_type = 8;
                elem(i).Nphi = 3;
                elem(i).coords = {'xi'};
                elem(i).phi = {'-xi*(1-xi)/2' , 'xi*(1+xi)/2','(1-xi^2)'};
                elem(i).nodes = [-1 1 0]';
                elem(i).entities = cell(2,2);
                elem(i).entities(1,:) = {'POINT', 1};
                elem(i).entities(2,:) = {'POINT', 2};
                elem(i).dof_entities = [1 2 0];
                elem(i).const_jac = 0;
                elem(i).integration_points_fct = @(NP) elem(i).gauss_points(elem(i).dim,NP);
                elem(i) = PROCESS_ELEMENT(elem(i));
                i = i+1;
            end
            
            if(strcmpi(el_name,'EDGE_HERMITE_VALUE') || strcmpi(el_name,'ALL'))
                elem(i).name='EDGE_HERMITE_VALUE';
                elem(i).shape='EDGE';
                elem(i).dim=1;
                elem(i).xdmf_name = ' ';
                elem(i).xdmf_type = NaN;
                elem(i).xdmf_cell_field = false;
                elem(i).gmsh_type = NaN;
                elem(i).Nphi = 2;
                elem(i).coords = {'xi'};
                elem(i).phi = {'(1-xi)*(1-xi)*(2+xi)/4' , '(1+xi)*(1+xi)*(2-xi)/4'};
                elem(i).nodes = [-1 1]';
                elem(i).entities = cell(2,2);
                elem(i).entities(1,:) = {'POINT', 1};
                elem(i).entities(2,:) = {'POINT', 2};
                elem(i).dof_entities = [1 2];
                elem(i).const_jac = 0;
                elem(i).integration_points_fct = @(NP) elem(i).gauss_points(elem(i).dim,NP);
                elem(i) = PROCESS_ELEMENT(elem(i));
                i = i+1;
            end
            
            if(strcmpi(el_name,'EDGE_HERMITE_SLOPE') || strcmpi(el_name,'ALL'))
                elem(i).name='EDGE_HERMITE_SLOPE';
                elem(i).shape='EDGE';
                elem(i).dim=1;
                elem(i).xdmf_name = ' ';
                elem(i).xdmf_type = NaN;
                elem(i).xdmf_cell_field = false;
                elem(i).gmsh_type = NaN;
                elem(i).Nphi = 2;
                elem(i).coords = {'xi'};
                elem(i).phi = {'(1-xi)*(1-xi)*(1+xi)/4', '-(1+xi)*(1+xi)*(1-xi)/4'};
                elem(i).nodes = [-1 1]';
                elem(i).entities = cell(2,2);
                elem(i).entities(1,:) = {'POINT', 1};
                elem(i).entities(2,:) = {'POINT', 2};
                elem(i).dof_entities = [1 2];
                elem(i).const_jac = 0;
                elem(i).integration_points_fct = @(NP) elem(i).gauss_points(elem(i).dim,NP);
                elem(i) = PROCESS_ELEMENT(elem(i));
                i = i+1;
            end
            
            if(strcmpi(el_name,'TRI_1') || strcmpi(el_name,'ALL'))
                elem(i).name='TRI_1';
                elem(i).shape='TRI';
                elem(i).dim=2;
                elem(i).gmsh_type = NaN;
                elem(i).xdmf_name = '';
                elem(i).xdmf_type = NaN;
                elem(i).xdmf_cell_field = true;
                elem(i).Nphi = 1;
                elem(i).coords = {'xi','eta'};
                elem(i).phi = {'1'};
                elem(i).nodes = [1 1]/3;
                elem(i).entities = cell(6,2);
                elem(i).entities(1,:) = {'POINT',  1};
                elem(i).entities(2,:) = {'POINT',  1};
                elem(i).entities(3,:) = {'POINT',  1};
                elem(i).entities(4,:) = {'EDGE_1', 1};
                elem(i).entities(5,:) = {'EDGE_1', 1};
                elem(i).entities(6,:) = {'EDGE_1', 1};
                elem(i).dof_entities=0;
                elem(i).const_jac = 1;
                elem(i).integration_points_fct = @(NP) elem(i).hammer_points(NP);
                elem(i) = PROCESS_ELEMENT(elem(i));
                i = i+1;
            end
            if(strcmpi(el_name,'TRI_3') || strcmpi(el_name,'ALL'))
                elem(i).name='TRI_3';
                elem(i).shape='TRI';
                elem(i).dim=2;
                elem(i).gmsh_type = 2;
                elem(i).xdmf_name = 'Triangle';
                elem(i).xdmf_type = 4;
                elem(i).xdmf_cell_field = false;
                elem(i).Nphi = 3;
                elem(i).coords = {'xi','eta'};
                elem(i).phi = {'1-xi-eta' , 'xi','eta'};
                elem(i).nodes = [0 0;1 0;0 1];
                elem(i).entities = cell(6,2);
                elem(i).entities(1,:) = {'POINT', 1};
                elem(i).entities(2,:) = {'POINT', 2};
                elem(i).entities(3,:) = {'POINT', 3};
                elem(i).entities(4,:) = {'EDGE_2', [1 2]};
                elem(i).entities(5,:) = {'EDGE_2', [2 3]};
                elem(i).entities(6,:) = {'EDGE_2', [3 1]};
                elem(i).dof_entities = [1 2 3];
                elem(i).const_jac = 1;
                elem(i).integration_points_fct = @(NP) elem(i).hammer_points(NP);
                elem(i) = PROCESS_ELEMENT(elem(i));
                i = i+1;
            end
            
            if(strcmpi(el_name,'TRI_4_BUBBLE') || strcmpi(el_name,'ALL'))
                elem(i).name='TRI_4_BUBBLE';
                elem(i).shape='TRI';
                elem(i).dim=2;
                elem(i).gmsh_type = NaN;
                elem(i).xdmf_name = '';
                elem(i).xdmf_type = NaN;
                elem(i).xdmf_cell_field = false;
                elem(i).Nphi = 4;
                elem(i).coords = {'xi','eta'};
                elem(i).phi = {'1-xi-eta' , 'xi','eta','-eta*xi*(xi+eta-1)/27'};
                elem(i).nodes = [0 1 0 1/3;0 0 1 1/3]';
                elem(i).entities = cell(6,2);
                elem(i).entities(1,:) = {'POINT', 1};
                elem(i).entities(2,:) = {'POINT', 2};
                elem(i).entities(3,:) = {'POINT', 3};
                elem(i).entities(4,:) = {'EDGE_2', [1 2]};
                elem(i).entities(5,:) = {'EDGE_2', [2 3]};
                elem(i).entities(6,:) = {'EDGE_2', [3 1]};
                elem(i).dof_entities = [1 2 3 0];
                elem(i).const_jac = 0;
                elem(i).integration_points_fct = @(NP) elem(i).hammer_points(NP);
                elem(i) = PROCESS_ELEMENT(elem(i));
                i = i+1;
            end
            if(strcmpi(el_name,'TRI_6') || strcmpi(el_name,'ALL'))
                elem(i).name='TRI_6';
                elem(i).shape='TRI';
                elem(i).dim=2;
                elem(i).gmsh_type = NaN;
                elem(i).xdmf_name = 'Triangle_6';
                elem(i).xdmf_type = NaN;
                elem(i).Nphi = 6;
                elem(i).coords = {'xi','eta'};
                elem(i).phi = {'(1-xi-eta)*(1-2*xi-2*eta)' , 'xi*(2*xi-1)','eta*(2*eta-1)','4*xi*(1-xi-eta)','4*eta*xi','4*eta*(1-xi-eta)'};
                elem(i).nodes = [0 1 0 1/2 1/2 0 ;0 0 1 0 1/2 1/2]';
                elem(i).entities = cell(6,2);
                elem(i).entities(1,:) = {'POINT', 1};
                elem(i).entities(2,:) = {'POINT', 2};
                elem(i).entities(3,:) = {'POINT', 3};
                elem(i).entities(4,:) = {'EDGE_3', [1 2 4]};
                elem(i).entities(5,:) = {'EDGE_3', [2 3 5]};
                elem(i).entities(6,:) = {'EDGE_3', [3 1 6]};
                elem(i).dof_entities = [1 2 3 4 5 6];
                elem(i).const_jac = 0;
                elem(i).integration_points_fct = @(NP) elem(i).hammer_points(NP);
                elem(i) = PROCESS_ELEMENT(elem(i));
                i = i+1;
                
            end
            
            
            if(strcmpi(el_name,'QUAD_1') || strcmpi(el_name,'ALL'))
                elem(i).name = 'QUAD_1';
                elem(i).shape='QUAD';
                elem(i).dim=2;
                elem(i).gmsh_type = NaN;
                elem(i).xdmf_name = '';
                elem(i).xdmf_type = NaN;
                elem(i).xdmf_cell_field = true;
                elem(i).Nphi = 1;
                elem(i).coords = {'xi','eta'};
                elem(i).phi = {'1'};
                elem(i).nodes = [0 0];
                elem(i).entities = cell(8,2);
                elem(i).entities(1,:) = {'POINT', 1};
                elem(i).entities(2,:) = {'POINT', 1};
                elem(i).entities(3,:) = {'POINT', 1};
                elem(i).entities(4,:) = {'POINT', 1};
                elem(i).entities(5,:) = {'EDGE_1',1};
                elem(i).entities(6,:) = {'EDGE_1',1};
                elem(i).entities(7,:) = {'EDGE_1',1};
                elem(i).entities(8,:) = {'EDGE_1',1};
                elem(i).dof_entities=0;
                elem(i).const_jac = 1;
                elem(i).integration_points_fct = @(NP) elem(i).gauss_points(elem(i).dim,NP);
                elem(i) = PROCESS_ELEMENT(elem(i));
                i = i+1;
            end
            if(strcmpi(el_name,'QUAD_4') || strcmpi(el_name,'ALL'))
                elem(i).name = 'QUAD_4';
                elem(i).shape='QUAD';
                elem(i).dim=2;
                elem(i).gmsh_type = 3;
                elem(i).xdmf_name = 'Quadrilateral';
                elem(i).xdmf_type = 5;
                elem(i).xdmf_cell_field = false;
                elem(i).Nphi = 4;
                elem(i).coords = {'xi','eta'};
                elem(i).phi = {'(1+xi)*(1+eta)/4','(1-xi)*(1+eta)/4','(1-xi)*(1-eta)/4','(1+xi)*(1-eta)/4'};
                elem(i).nodes = [1 1;-1 1;-1 -1;1 -1];
                elem(i).entities = cell(8,2);
                elem(i).entities(1,:) = {'POINT', 1};
                elem(i).entities(2,:) = {'POINT', 2};
                elem(i).entities(3,:) = {'POINT', 3};
                elem(i).entities(4,:) = {'POINT', 4};
                elem(i).entities(5,:) = {'EDGE_2', [1 2]};
                elem(i).entities(6,:) = {'EDGE_2', [2 3]};
                elem(i).entities(7,:) = {'EDGE_2', [3 4]};
                elem(i).entities(8,:) = {'EDGE_2', [4 1]};
                elem(i).dof_entities = [1 2 3 4];
                elem(i).const_jac = 0;
                elem(i).integration_points_fct = @(NP) elem(i).gauss_points(elem(i).dim,NP);
                elem(i) = PROCESS_ELEMENT(elem(i));
                i = i+1;
            end
            if(strcmpi(el_name,'QUAD_LEGENDRE2') || strcmpi(el_name,'ALL'))
                elem(i).name = 'QUAD_LEGENDRE2';
                elem(i).shape='QUAD';
                elem(i).dim=2;
                elem(i).gmsh_type = NaN;
                elem(i).xdmf_name = '';
                elem(i).xdmf_type = NaN;
                elem(i).Nphi = 4;
                elem(i).coords = {'xi','eta'};
                elem(i).phi = {'(1+sqrt(3)*xi)*(1+sqrt(3)*eta)/4',...
                    '(1-sqrt(3)*xi)*(1+sqrt(3)*eta)/4',...
                    '(1-sqrt(3)*xi)*(1-sqrt(3)*eta)/4',...
                    '(1+sqrt(3)*xi)*(1-sqrt(3)*eta)/4'};
                elem(i).nodes = [1 1;-1 1;-1 -1;1 -1]*sqrt(3)/3;
                elem(i).entities = cell(8,2);
                elem(i).entities(1,:) = {'POINT', 1};
                elem(i).entities(2,:) = {'POINT', 2};
                elem(i).entities(3,:) = {'POINT', 3};
                elem(i).entities(4,:) = {'POINT', 4};
                elem(i).entities(5,:) = {'EDGE_1', 1};
                elem(i).entities(6,:) = {'EDGE_1', 2};
                elem(i).entities(7,:) = {'EDGE_1', 3};
                elem(i).entities(8,:) = {'EDGE_1', 4};
                elem(i).dof_entities = [0 0 0 0];
                elem(i).const_jac = 0;
                elem(i).integration_points_fct = @(NP) elem(i).gauss_points(elem(i).dim,NP);
                elem(i) = PROCESS_ELEMENT(elem(i));
                i = i+1;
            end
            if(strcmpi(el_name,'QUAD_LEGENDRE3') || strcmpi(el_name,'ALL'))
                elem(i).name = 'QUAD_LEGENDRE3';
                elem(i).shape='QUAD';
                elem(i).dim=2;
                elem(i).gmsh_type = NaN;
                elem(i).xdmf_name = '';
                elem(i).xdmf_type = NaN;
                elem(i).Nphi = 9;
                elem(i).coords = {'xi','eta'};
                elem(i).phi = { '5*xi*(sqrt(3/5)+xi)/6*5*eta*(sqrt(3/5)+eta)/6',...
                    '-5*xi*(sqrt(3/5)-xi)/6*5*eta*(sqrt(3/5)+eta)/6',...
                    '-5*xi*(sqrt(3/5)-xi)/6*-5*eta*(sqrt(3/5)-eta)/6' ,...
                    '5*xi*(sqrt(3/5)+xi)/6*-5*eta*(sqrt(3/5)-eta)/6',...
                    '(1-5*(xi^2)/3)*5*eta*(sqrt(3/5)+eta)/6',...
                    '-5*xi*(sqrt(3/5)-xi)/6*(1-5*(eta^2)/3)',...
                    '(1-5*(xi^2)/3)*-5*eta*(sqrt(3/5)-eta)/6',...
                    '5*xi*(sqrt(3/5)+xi)/6*(1-5*(eta^2)/3)',...
                    '(1-5*(xi^2)/3)*(1-5*(eta^2)/3)'};
                elem(i).nodes = [1 1;-1 1;-1 -1;1 -1;0 1;-1 0;0 -1;1 0;0 0]*sqrt(3/5);
                elem(i).entities = cell(8,2);
                elem(i).entities(1,:) = {'POINT', 1};
                elem(i).entities(2,:) = {'POINT', 2};
                elem(i).entities(3,:) = {'POINT', 3};
                elem(i).entities(4,:) = {'POINT', 4};
                elem(i).entities(5,:) = {'EDGE_1', 1};
                elem(i).entities(6,:) = {'EDGE_1', 2};
                elem(i).entities(7,:) = {'EDGE_1', 3};
                elem(i).entities(8,:) = {'EDGE_1', 4};
                elem(i).dof_entities = [0 0 0 0 0 0 0 0 0];
                elem(i).const_jac = 0;
                elem(i).integration_points_fct = @(NP) elem(i).gauss_points(elem(i).dim,NP);
                elem(i) = PROCESS_ELEMENT(elem(i));
                i = i+1;
            end
            if(strcmpi(el_name,'QUAD_9') || strcmpi(el_name,'ALL'))
                elem(i).name = 'QUAD_9';
                elem(i).shape='QUAD';
                elem(i).dim=2;
                elem(i).gmsh_type = 10;
                elem(i).xdmf_name = 'Quadrilateral_9';
                elem(i).xdmf_type = 35;
                elem(i).xdmf_cell_field = false;
                elem(i).Nphi = 9;
                elem(i).coords = {'xi','eta'};
                elem(i).phi = {'xi*(1+xi)*eta*(1+eta)/4','-xi*(1-xi)*eta*(1+eta)/4','xi*(1-xi)*eta*(1-eta)/4','-xi*(1+xi)*eta*(1-eta)/4',...
                    '(1+xi)*(1-xi)*eta*(1+eta)/2','-xi*(1-xi)*(1-eta)*(1+eta)/2','-(1-xi)*(1+xi)*eta*(1-eta)/2','xi*(1+xi)*(1-eta)*(1+eta)/2',...
                    '(1-xi)*(1+xi)*(1-eta)*(1+eta)'};
                elem(i).nodes = [1 1;-1 1;-1 -1;1 -1;0 1;-1 0;0 -1;1 0;0 0];
                elem(i).entities = cell(8,2);
                elem(i).entities(1,:) = {'POINT', 1};
                elem(i).entities(2,:) = {'POINT', 2};
                elem(i).entities(3,:) = {'POINT', 3};
                elem(i).entities(4,:) = {'POINT', 4};
                elem(i).entities(5,:) = {'EDGE_3', [1 2 5]};
                elem(i).entities(6,:) = {'EDGE_3', [2 3 6]};
                elem(i).entities(7,:) = {'EDGE_3', [3 4 7]};
                elem(i).entities(8,:) = {'EDGE_3', [4 1 8]};
                elem(i).dof_entities = [1 2 3 4 5 6 7 8 0];
                elem(i).const_jac = 0;
                elem(i).integration_points_fct = @(NP) elem(i).gauss_points(elem(i).dim,NP);
                elem(i) = PROCESS_ELEMENT(elem(i));
                i = i+1;
            end
            %             if(strcmpi(el_name,'HEX_8') || strcmpi(el_name,'ALL'))
            %                 elem(i).name = 'HEX_8';
            %                 elem(i).shape = 'HEX';
            %                 elem(i).dim = 3;
            %                 elem(i).gmsh_type = 5;
            %                 elem(i).xdmf_name = 'Hexahedron';
            %                 elem(i).xdmf_type = 9;
            %                 elem(i).xdmf_cell_field = false;
            %                 elem(i).Nphi = 8;
            %                 elem(i).coords = {'xi','eta','psi'};
            %                 elem(i).phi = {'(1+xi)*(1+eta)*(1-psi)/8','(1-xi)*(1+eta)*(1-psi)/8','(1-xi)*(1-eta)*(1-psi)/8','(1+xi)*(1-eta)*(1-psi)/8',...
            %                     '(1+xi)*(1+eta)*(1+psi)/8','(1-xi)*(1+eta)*(1+psi)/8','(1-xi)*(1-eta)*(1+psi)/8','(1+xi)*(1-eta)*(1+psi)/8'};
            %                 elem(i).nodes = [1 1 -1;-1 1 -1;-1 -1 -1;1 -1 -1;1 1 1;-1 1 1;-1 -1 1;1 -1 1];
            %                 elem(i).entities = cell(26,2);
            %                 elem(i).entities(1,:) = {'POINT', 1};
            %                 elem(i).entities(2,:) = {'POINT', 2};
            %                 elem(i).entities(3,:) = {'POINT', 3};
            %                 elem(i).entities(4,:) = {'POINT', 4};
            %                 elem(i).entities(5,:) = {'POINT', 5};
            %                 elem(i).entities(6,:) = {'POINT', 6};
            %                 elem(i).entities(7,:) = {'POINT', 7};
            %                 elem(i).entities(8,:) = {'POINT', 8};
            %                 elem(i).entities(9,:) = {'EDGE_2', [1 2]};
            %                 elem(i).entities(10,:) = {'EDGE_2', [2 3]};
            %                 elem(i).entities(11,:) = {'EDGE_2', [3 4]};
            %                 elem(i).entities(12,:) = {'EDGE_2', [4 1]};
            %                 elem(i).entities(13,:) = {'EDGE_2', [5 6]};
            %                 elem(i).entities(14,:) = {'EDGE_2', [6 7]};
            %                 elem(i).entities(15,:) = {'EDGE_2', [7 8]};
            %                 elem(i).entities(16,:) = {'EDGE_2', [8 5]};
            %                 elem(i).entities(17,:) = {'EDGE_2', [1 5]};
            %                 elem(i).entities(18,:) = {'EDGE_2', [2 6]};
            %                 elem(i).entities(19,:) = {'EDGE_2', [3 7]};
            %                 elem(i).entities(20,:) = {'EDGE_2', [4 8]};
            %                 elem(i).entities(21,:) = {'QUAD_4', fliplr([2 1 4 3])};
            %                 elem(i).entities(22,:) = {'QUAD_4', [5 6 7 8]};
            %                 elem(i).entities(23,:) = {'QUAD_4', [5 8 4 1]};
            %                 elem(i).entities(24,:) = {'QUAD_4', fliplr([7 6 2 3])};
            %                 elem(i).entities(25,:) = {'QUAD_4', fliplr([6 5 1 2])};
            %                 elem(i).entities(26,:) = {'QUAD_4', [8 7 3 4]};
            %                 elem(i).dof_entities = [1 2 3 4 5 6 7 8];
            %                 elem(i).const_jac = 0;
            %                 elem(i).integration_points_fct = @(NP) elem(i).gauss_points(elem(i).dim,NP);
            %                 elem(i) = PROCESS_ELEMENT(elem(i));
            %                 i = i+1;
            %             end
            if(strcmpi(el_name,'HEX_8') || strcmpi(el_name,'ALL'))
                elem(i).name = 'HEX_8';
                elem(i).shape = 'HEX';
                elem(i).dim = 3;
                elem(i).gmsh_type = 5;
                elem(i).xdmf_name = 'Hexahedron';
                elem(i).xdmf_type = 9;
                elem(i).xdmf_cell_field = false;
                elem(i).Nphi = 8;
                elem(i).coords = {'x','y','z'};
                elem(i).phi = { '-(x/2 - 1/2)*(y/2 - 1/2)*(z/2 - 1/2)',...
                                '(x/2 + 1/2)*(y/2 - 1/2)*(z/2 - 1/2)',...
                                '-(x/2 + 1/2)*(y/2 + 1/2)*(z/2 - 1/2)',...
                                '(x/2 - 1/2)*(y/2 + 1/2)*(z/2 - 1/2)',...
                                '(x/2 - 1/2)*(y/2 - 1/2)*(z/2 + 1/2)',...
                                '-(x/2 + 1/2)*(y/2 - 1/2)*(z/2 + 1/2)',...
                                '(x/2 + 1/2)*(y/2 + 1/2)*(z/2 + 1/2)',...
                                '-(x/2 - 1/2)*(y/2 + 1/2)*(z/2 + 1/2)'};
                elem(i).nodes = [ -1    -1    -1 ;...
                                   1    -1    -1 ;...
                                   1     1    -1 ;...
                                  -1     1    -1 ;...
                                  -1    -1     1 ;...
                                   1    -1     1 ;...
                                   1     1     1 ;...
                                  -1     1     1];
                elem(i).entities = cell(26,2);
                elem(i).entities(1,:) = {'POINT', 1};
                elem(i).entities(2,:) = {'POINT', 2};
                elem(i).entities(3,:) = {'POINT', 3};
                elem(i).entities(4,:) = {'POINT', 4};
                elem(i).entities(5,:) = {'POINT', 5};
                elem(i).entities(6,:) = {'POINT', 6};
                elem(i).entities(7,:) = {'POINT', 7};
                elem(i).entities(8,:) = {'POINT', 8};
                elem(i).entities(9,:) = {'EDGE_2', [1 2]};
                elem(i).entities(10,:) = {'EDGE_2', [2 3]};
                elem(i).entities(11,:) = {'EDGE_2', [3 4]};
                elem(i).entities(12,:) = {'EDGE_2', [4 1]};
                elem(i).entities(13,:) = {'EDGE_2', [5 6]};
                elem(i).entities(14,:) = {'EDGE_2', [6 7]};
                elem(i).entities(15,:) = {'EDGE_2', [7 8]};
                elem(i).entities(16,:) = {'EDGE_2', [8 5]};
                elem(i).entities(17,:) = {'EDGE_2', [1 5]};
                elem(i).entities(18,:) = {'EDGE_2', [2 6]};
                elem(i).entities(19,:) = {'EDGE_2', [3 7]};
                elem(i).entities(20,:) = {'EDGE_2', [4 8]};
                elem(i).entities(21,:) = {'QUAD_4', [4 1 5 8]};
                elem(i).entities(22,:) = {'QUAD_4', [2 3 7 6]};
                elem(i).entities(23,:) = {'QUAD_4', [1 2 6 5]};
                elem(i).entities(24,:) = {'QUAD_4', [3 4 8 7]};
                elem(i).entities(25,:) = {'QUAD_4', [1 4 3 2]};
                elem(i).entities(26,:) = {'QUAD_4', [5 6 7 8]};
                elem(i).dof_entities = [1 2 3 4 5 6 7 8];
                elem(i).const_jac = 0;
                elem(i).integration_points_fct = @(NP) elem(i).gauss_points(elem(i).dim,NP);
                elem(i) = PROCESS_ELEMENT(elem(i));
                i = i+1;
            end
            if(strcmpi(el_name,'HEX_27') || strcmpi(el_name,'ALL'))
                elem(i).name = 'HEX_27';
                elem(i).shape = 'HEX';
                elem(i).dim = 3;
                elem(i).gmsh_type = NaN;
                elem(i).xdmf_name = 'Hexahedron_27';
                elem(i).xdmf_type = 50;
                elem(i).xdmf_cell_field = false;
                elem(i).Nphi = 27;
                elem(i).coords = {'x','y','z'};
                elem(i).phi = {'(x*y*z*(x - 1)*(y - 1)*(z - 1))/8',  '(x*y*z*(x + 1)*(y - 1)*(z - 1))/8',  '(x*y*z*(x + 1)*(y + 1)*(z - 1))/8',...
                    '(x*y*z*(x - 1)*(y + 1)*(z - 1))/8',  '(x*y*z*(x - 1)*(y - 1)*(z + 1))/8',  '(x*y*z*(x + 1)*(y - 1)*(z + 1))/8',...
                    '(x*y*z*(x + 1)*(y + 1)*(z + 1))/8',  '(x*y*z*(x - 1)*(y + 1)*(z + 1))/8',  '-(y*z*(x - 1)*(x + 1)*(y - 1)*(z - 1))/4',...
                    '-(x*z*(x + 1)*(y - 1)*(y + 1)*(z - 1))/4',  '-(y*z*(x - 1)*(x + 1)*(y + 1)*(z - 1))/4',  '-(x*z*(x - 1)*(y - 1)*(y + 1)*(z - 1))/4',...
                    '-(y*z*(x - 1)*(x + 1)*(y - 1)*(z + 1))/4',  '-(x*z*(x + 1)*(y - 1)*(y + 1)*(z + 1))/4',  '-(y*z*(x - 1)*(x + 1)*(y + 1)*(z + 1))/4',...
                    '-(x*z*(x - 1)*(y - 1)*(y + 1)*(z + 1))/4',  '-(x*y*(x - 1)*(y - 1)*(z - 1)*(z + 1))/4',  '-(x*y*(x + 1)*(y - 1)*(z - 1)*(z + 1))/4',...
                    '-(x*y*(x + 1)*(y + 1)*(z - 1)*(z + 1))/4',  '-(x*y*(x - 1)*(y + 1)*(z - 1)*(z + 1))/4',  '(x*(x - 1)*(y - 1)*(y + 1)*(z - 1)*(z + 1))/2',...
                    '(x*(x + 1)*(y - 1)*(y + 1)*(z - 1)*(z + 1))/2',  '(y*(x - 1)*(x + 1)*(y - 1)*(z - 1)*(z + 1))/2',  '(y*(x - 1)*(x + 1)*(y + 1)*(z - 1)*(z + 1))/2',...
                    '(z*(x - 1)*(x + 1)*(y - 1)*(y + 1)*(z - 1))/2',  '(z*(x - 1)*(x + 1)*(y - 1)*(y + 1)*(z + 1))/2',  '-(x - 1)*(x + 1)*(y - 1)*(y + 1)*(z - 1)*(z + 1)'};
                elem(i).nodes = [ -1    -1    -1 ;    1    -1    -1  ;   1     1    -1  ;  -1     1    -1  ;  -1    -1     1   ;  1    -1     1 ;...
                    1     1     1 ;   -1     1     1  ;   0    -1    -1  ;   1     0    -1  ;   0     1    -1   ; -1     0    -1 ;...
                    0    -1     1 ;    1     0     1  ;   0     1     1  ;  -1     0     1  ;  -1    -1     0   ;  1    -1     0 ;...
                    1     1     0 ;   -1     1     0  ;  -1     0     0  ;   1     0     0  ;   0    -1     0   ;  0     1     0 ;...
                    0     0    -1 ;    0     0     1  ;   0     0     0];
                
                elem(i).entities = cell(26,2);
                elem(i).entities(1,:) = {'POINT', 1};
                elem(i).entities(2,:) = {'POINT', 2};
                elem(i).entities(3,:) = {'POINT', 3};
                elem(i).entities(4,:) = {'POINT', 4};
                elem(i).entities(5,:) = {'POINT', 5};
                elem(i).entities(6,:) = {'POINT', 6};
                elem(i).entities(7,:) = {'POINT', 7};
                elem(i).entities(8,:) = {'POINT', 8};
                elem(i).entities(9,:) = {'EDGE_3', [1 2 9]};
                elem(i).entities(10,:) = {'EDGE_3', [2 3 10]};
                elem(i).entities(11,:) = {'EDGE_3', [3 4 11]};
                elem(i).entities(12,:) = {'EDGE_3', [4 1 12]};
                elem(i).entities(13,:) = {'EDGE_3', [5 6 13]};
                elem(i).entities(14,:) = {'EDGE_3', [6 7 14]};
                elem(i).entities(15,:) = {'EDGE_3', [7 8 15]};
                elem(i).entities(16,:) = {'EDGE_3', [8 5 16]};
                elem(i).entities(17,:) = {'EDGE_3', [1 5 17]};
                elem(i).entities(18,:) = {'EDGE_3', [2 6 18]};
                elem(i).entities(19,:) = {'EDGE_3', [3 7 19]};
                elem(i).entities(20,:) = {'EDGE_3', [4 8 20]};
                elem(i).entities(21,:) = {'QUAD_9', [4 1 5 8 12 17 16 20 21]};
                elem(i).entities(22,:) = {'QUAD_9', [2 3 7 6 10 19 14 18 22]};
                elem(i).entities(23,:) = {'QUAD_9', [1 2 6 5 9 18 13 17 23]};
                elem(i).entities(24,:) = {'QUAD_9', [3 4 8 7 11 20 15 19 24]};
                elem(i).entities(25,:) = {'QUAD_9', [1 4 3 2 12 11 10 9 25]};
                elem(i).entities(26,:) = {'QUAD_9', [5 6 7 8 13 14 15 16 26]};
                elem(i).dof_entities = [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 0];
                
                elem(i).const_jac = 0;
                elem(i).integration_points_fct = @(NP) elem(i).gauss_points(elem(i).dim,NP);
                elem(i) = PROCESS_ELEMENT(elem(i));
                i = i+1;
            end
            
            if(strcmpi(el_name,'HEX_1') || strcmpi(el_name,'ALL'))
                elem(i).name = 'HEX_1';
                elem(i).shape = 'HEX';
                elem(i).dim = 3;
                elem(i).gmsh_type = 5;
                elem(i).xdmf_name = '';
                elem(i).xdmf_type = NaN;
                elem(i).xdmf_cell_field = true;
                elem(i).Nphi = 1;
                elem(i).coords = {'xi','eta','psi'};
                elem(i).phi = {'1'};
                elem(i).nodes = [0 0 0];
                elem(i).entities = cell(26,2);
                elem(i).entities(1,:) = {'POINT', 1};
                elem(i).entities(2,:) = {'POINT', 2};
                elem(i).entities(3,:) = {'POINT', 3};
                elem(i).entities(4,:) = {'POINT', 4};
                elem(i).entities(5,:) = {'POINT', 5};
                elem(i).entities(6,:) = {'POINT', 6};
                elem(i).entities(7,:) = {'POINT', 7};
                elem(i).entities(8,:) = {'POINT', 8};
                elem(i).entities(9,:) = {'EDGE_2', [1 2]};
                elem(i).entities(10,:) = {'EDGE_2', [2 3]};
                elem(i).entities(11,:) = {'EDGE_2', [3 4]};
                elem(i).entities(12,:) = {'EDGE_2', [4 1]};
                elem(i).entities(13,:) = {'EDGE_2', [5 6]};
                elem(i).entities(14,:) = {'EDGE_2', [6 7]};
                elem(i).entities(15,:) = {'EDGE_2', [7 8]};
                elem(i).entities(16,:) = {'EDGE_2', [8 5]};
                elem(i).entities(17,:) = {'EDGE_2', [1 5]};
                elem(i).entities(18,:) = {'EDGE_2', [2 6]};
                elem(i).entities(19,:) = {'EDGE_2', [3 7]};
                elem(i).entities(20,:) = {'EDGE_2', [4 8]};
                elem(i).entities(21,:) = {'QUAD_4', [2 1 4 3]};
                elem(i).entities(22,:) = {'QUAD_4', [5 6 7 8]};
                elem(i).entities(23,:) = {'QUAD_4', [5 8 4 1]};
                elem(i).entities(24,:) = {'QUAD_4', [7 6 2 3]};
                elem(i).entities(25,:) = {'QUAD_4', [6 5 1 2]};
                elem(i).entities(26,:) = {'QUAD_4', [8 7 3 4]};
                elem(i).dof_entities = [0];
                elem(i).const_jac = 0;
                elem(i).integration_points_fct = @(NP) elem(i).gauss_points(elem(i).dim,NP);
                elem(i) = PROCESS_ELEMENT(elem(i));
                i = i+1;
            end
            
            if(strcmpi(el_name,'TET_4') || strcmpi(el_name,'ALL'))
                elem(i).name = 'TET_4';
                elem(i).shape='TET';
                elem(i).dim=3;
                elem(i).gmsh_type = 4;
                elem(i).xdmf_name = 'Tetrahedron';
                elem(i).xdmf_type = 6;
                elem(i).xdmf_cell_field = false;
                elem(i).Nphi = 4;
                elem(i).coords = {'xi','eta','nu'};
                elem(i).phi = {'1-xi-eta-nu','xi','eta','nu'};
                elem(i).nodes = [0 0 0; 1 0 0; 0 1 0; 0 0 1];
                elem(i).entities = cell(14,2);
                elem(i).entities(1,:) = {'POINT', 1};
                elem(i).entities(2,:) = {'POINT', 2};
                elem(i).entities(3,:) = {'POINT', 3};
                elem(i).entities(4,:) = {'POINT', 4};
                elem(i).entities(5,:) = {'EDGE_2', [1 2]};
                elem(i).entities(6,:) = {'EDGE_2', [2 3]};
                elem(i).entities(7,:) = {'EDGE_2', [3 1]};
                elem(i).entities(8,:) = {'EDGE_2', [1 4]};
                elem(i).entities(9,:) = {'EDGE_2', [2 4]};
                elem(i).entities(10,:) = {'EDGE_2', [3 4]};
                elem(i).entities(11,:) = {'TRI_3', [1 3 2]};
                elem(i).entities(12,:) = {'TRI_3', [1 2 4]};
                elem(i).entities(13,:) = {'TRI_3', [2 3 4]};
                elem(i).entities(14,:) = {'TRI_3', [3 1 4]};
                elem(i).dof_entities = [1 2 3 4];
                elem(i).const_jac = 0;
                elem(i).integration_points_fct = @(NP) elem(i).tet_points(NP);
                elem(i) = PROCESS_ELEMENT(elem(i));
                i = i+1; %#ok<NASGU>
            end
            if(strcmpi(el_name,'TET_10') || strcmpi(el_name,'ALL'))
                elem(i).name = 'TET_10';
                elem(i).shape='TET';
                elem(i).dim=3;
                elem(i).gmsh_type = 11;
                elem(i).xdmf_name = 'Tet_10';
                elem(i).xdmf_type = 24;
                elem(i).xdmf_cell_field = false;
                elem(i).Nphi = 10;
                elem(i).coords = {'xi','eta','nu'};
                elem(i).phi = {'2*eta*eta + 4*eta*nu + 4*eta*xi - 3*eta + 2*nu*nu + 4*nu*xi - 3*nu + 2*xi*xi - 3*xi + 1',...
                    '2*xi*xi - xi',...
                    '2*eta*eta - eta',...
                    '2*nu*nu - nu',...
                    '-4*xi*(eta + nu + xi - 1)',...
                    '4*eta*xi',...
                    '-4*eta*(eta + nu + xi - 1)',...
                    '-4*nu*(eta + nu + xi - 1)',...
                    '4*xi*nu',...
                    '4*eta*nu'...
                    };
                elem(i).nodes = [0 0 0; 1 0 0; 0 1 0; 0 0 1;0.5 0 0;0.5 0.5 0;0 0.5 0;0 0 0.5;0.5 0 0.5; 0 0.5 0.5];
                elem(i).entities = cell(14,2);
                elem(i).entities(1,:) = {'POINT', 1};
                elem(i).entities(2,:) = {'POINT', 2};
                elem(i).entities(3,:) = {'POINT', 3};
                elem(i).entities(4,:) = {'POINT', 4};
                elem(i).entities(5,:) = {'EDGE_3', [1 2 5]};
                elem(i).entities(6,:) = {'EDGE_3', [2 3 6]};
                elem(i).entities(7,:) = {'EDGE_3', [3 1 7]};
                elem(i).entities(8,:) = {'EDGE_3', [1 4 8]};
                elem(i).entities(9,:) = {'EDGE_3', [2 4 9]};
                elem(i).entities(10,:) = {'EDGE_3', [3 4 10]};
                elem(i).entities(11,:) = {'TRI_6', [1 3 2 7 6 5]};
                elem(i).entities(12,:) = {'TRI_6', [1 2 4 5 9 8]};
                elem(i).entities(13,:) = {'TRI_6', [2 3 4 6 10 9]};
                elem(i).entities(14,:) = {'TRI_6', [3 1 4 7 8 10]};
                elem(i).dof_entities = [1 2 3 4 5 6 7 8 9 10];
                elem(i).const_jac = 0;
                elem(i).integration_points_fct = @(NP) elem(i).tet_points(NP);
                elem(i) = PROCESS_ELEMENT(elem(i));
                i = i+1; %#ok<NASGU>
            end
            
            if strcmpi(el_name,'ALL')
                p = sort_dim(elem);
                elem = elem(p);
                save ELEMENT_LIB.mat elem;
            end
            return;
        end % CONSTRUCTOR
        
        function result = entity_name(elem,id)
            %returns the names of all the generated entities (sub-elements).
            result = elem.entities{id,1};
        end
        
        function [pos] = identify_entity(elem,name)
            %finds the sub-elements of a given type.
            pos = find(strcmpi(name,elem.entities(:,1)));
        end
        
        function [name,TAB] = entity_table(elem,TX0,id)
            %generates the connectivity of the sub-element #id from the
            %connectivity of the element elem.
            %NB: this function is vectorized accepts multiple lines (i.e. multiple instances of an element type)in TX0.
            assert(id<=elem.Nentities,'id > Nentities');
            TAB = TX0(:,elem.entities{id,2});
            name = elem.entities{id,1};
        end
        
        function result = check_shape(elem1,elem2)
            result = strcmp(elem1.shape,elem2.shape);
        end
        
        %         function W = prepare_integration(ELEMENTS,varargin)
        %             %precomputes the value of the shape functions and their
        %             %derivatives at the integration points given by integration_fct function pointer
        %             % [Xe,W] = integration_fct(dim,NP)
        %             %Xe: Neval by dim matrix of integration points
        %             %W : Neval by 1 vector of integration points
        %             %If nargin==2 the default function is used.
        %             %the function integration_fct is called with the argument NP.
        %
        %             NP = varargin{1};
        %             default_fct = true;
        %             if numel(varargin)>1
        %                 default_fct = false;
        %                 integration_fct = varargin{2};
        %             end
        %
        %                 if isempty(ELEMENTS.name)
        %                     return;
        %                 end
        %                 if ~default_fct
        %                     [ELEMENTS.eval_xi,ELEMENTS.eval_weights] = integration_fct(NP);
        %                 else
        %                     [ELEMENTS.eval_xi,ELEMENTS.eval_weights] = ELEMENTS.integration_points_fct(NP);
        %                 end
        %                 ELEMENTS.Neval = numel(ELEMENTS.eval_weights);
        %
        %                 ELEMENTS.eval_phi = repmat(ELEMENTS.fct_phi,[ELEMENTS.Neval 1]);
        %                 for ev = 1:ELEMENTS.Neval
        %                         ELEMENTS.eval_phi(ev,:) = subs(ELEMENTS.eval_phi(ev,:),ELEMENTS.fct_xi,ELEMENTS.eval_xi(ev,:));
        %                 end
        %                 ELEMENTS.eval_phi = sym2double(ELEMENTS.eval_phi);
        %                 ELEMENTS.eval_dphidxi = cell(ELEMENTS.Neval,1);
        %                 for j=1:ELEMENTS.Neval
        %                     ELEMENTS.eval_dphidxi{j} = sym2double(subs(ELEMENTS.fct_dphidxi,ELEMENTS.fct_xi,ELEMENTS.eval_xi(j,:)))';
        %                 end
        %                 W = ELEMENTS.eval_weights;
        %         end
        %
        function W = prepare_integration(ELEMENTS,varargin)
            %precomputes the value of the shape functions and their
            %derivatives at the integration points given by integration_fct function pointer
            % [Xe,W] = integration_fct(dim,NP)
            %Xe: Neval by dim matrix of integration points
            %W : Neval by 1 vector of integration points
            %If nargin==2 the default function is used.
            %the function integration_fct is called with the argument NP.
            
            NP = varargin{1};
            default_fct = true;
            if numel(varargin)>1
                default_fct = false;
                integration_fct = varargin{2};
            end
            
            if isempty(ELEMENTS.name)
                return;
            end
            if ~default_fct
                [ELEMENTS.eval_xi,ELEMENTS.eval_weights] = integration_fct(NP);
            else
                [ELEMENTS.eval_xi,ELEMENTS.eval_weights] = ELEMENTS.integration_points_fct(NP);
            end
            ELEMENTS.Neval = numel(ELEMENTS.eval_weights);
            
            ELEMENTS.eval_phi = zeros(ELEMENTS.Neval,ELEMENTS.Nphi);
            
            for ev = 1:ELEMENTS.Neval
                loc_arg = num2cell(ELEMENTS.eval_xi(ev,:));
                for fct = 1:ELEMENTS.Nphi
                    ELEMENTS.eval_phi(ev,fct) = ELEMENTS.fct_phi{fct}(loc_arg{:});
                end
            end
            ELEMENTS.eval_dphidxi = cell(ELEMENTS.Neval,1);
            for j=1:ELEMENTS.Neval
                loc_arg = num2cell(ELEMENTS.eval_xi(j,:));
                ELEMENTS.eval_dphidxi{j} = zeros(numel(ELEMENTS.coords),ELEMENTS.Nphi);
                for fct = 1:ELEMENTS.Nphi
                    for direc = 1:numel(ELEMENTS.coords)
                        ELEMENTS.eval_dphidxi{j}(direc,fct) = ELEMENTS.fct_dphidxi{fct,direc}(loc_arg{:});
                    end
                end
            end
            W = ELEMENTS.eval_weights;
        end
        
        
        
        %         function W = prepare_integration(ELEMENTS,varargin)
        %             %precomputes the value of the shape functions and their
        %             %derivatives at the integration points given by integration_fct function pointer
        %             % [Xe,W] = integration_fct(dim,NP)
        %             %Xe: Neval by dim matrix of integration points
        %             %W : Neval by 1 vector of integration points
        %             %If nargin==2 the default function is used.
        %             %the function integration_fct is called with the argument NP.
        %
        %             NP = varargin{1};
        %             default_fct = true;
        %             if numel(varargin)>1
        %                 default_fct = false;
        %                 integration_fct = varargin{2};
        %             end
        %
        %                 if isempty(ELEMENTS.name)
        %                     return;
        %                 end
        %                 if ~default_fct
        %                     [ELEMENTS.eval_xi,ELEMENTS.eval_weights] = integration_fct(NP);
        %                 else
        %                     [ELEMENTS.eval_xi,ELEMENTS.eval_weights] = ELEMENTS.integration_points_fct(NP);
        %                 end
        %                 ELEMENTS.Neval = numel(ELEMENTS.eval_weights);
        %                 tmp  =cellfun(@(a) a(ELEMENTS.eval_xi),ELEMENTS.fct_phi,'uniformoutput',false);
        %                 ELEMENTS.eval_phi = horzcat(tmp{:});
        %                 ELEMENTS.eval_dphidxi = cell(ELEMENTS.Neval,1);
        %                 for j=1:ELEMENTS.Neval
        %                     ELEMENTS.eval_dphidxi{j} = cellfun(@(a) a(ELEMENTS.eval_xi(j,:)),ELEMENTS.fct_dphidxi)';
        %                 end
        %                 W = ELEMENTS.eval_weights;
        %
        %         end
        
        
        function [n] = normal(~,J)
            %computes the normal vector at the gauss points
            %works only for a segment in a 2D mesh or a face in a 3D mesh
            if all(size(J{1})==[1 2])
                n = zeros(numel(J),2);
                for i=1:numel(J)
                    n(i,:) = [J{i}(2) -J{i}(1)];
                end
            elseif all(size(J{1})==[2 3])
                n = zeros(numel(J),3);
                for i=1:numel(J)
                    n(i,:) = cross(J{i}(1,:),J{i}(2,:));
                end
            else
                error('requires a segment in a 2D mesh or a face in a 3D mesh')
            end
            n = bsxfun(@rdivide,n,sqrt(sum(n.^2,2)));
        end
        
        function [J,detJ] = jacobian(obj,Xi)
            %computes the jacobian matrix and the jacobian for all the
            %integration points of the element if its coordinantes are
            %given by the Xi matrix (one line per node)
            %J is a cell array of matrices of length Neval
            %J is a vector of length Neval.
            
            %Evaluates all the jacobian matrices
            %if obj.const_jac
            %    J = {obj.eval_dphidxi{1}*Xi};
            %else
            J = cell(obj.Neval,1);
            for i=1:obj.Neval
                J{i} = obj.eval_dphidxi{i}*Xi;
            end
            %end
            %compares the dimension of the element with the dimension of
            %the space it lives in
            switch obj.dim
                case 0
                    detJ = ones(size(J));
                case size(Xi,2) % same dimension detJ  = det(J)
                    %detJ = zeros(size(J));
                    %for i=1:obj.Neval, detJ(i)=det(J{i}); end
                    detJ = cellfun(@det,J);
                case 1 % 1 we have an edge in a higher dimension: detJ = norm(J)
                    %detJ = zeros(size(J));
                    %for i=1:obj.Neval, detJ(i)=norm(J{i}); end
                    detJ = cellfun(@norm,J);
                case 2 % 2 we have a face in a higher dimension, not implemented
                    detJ = cellfun(@(arg) norm(cross(arg(1,:),arg(2,:))),J);
            end
            %if obj.const_jac
            %    J = J{1};
            %end
        end
        
        function [vals] = eval_field(element,Xi,J,ders)
            %Evaluates at the integration points the value of the field described by the element and the nodal
            %values Xi or the value of a derivative in real space (ders may contain a single non zero value identifying the dimension along which the derivative is taken).
            %J is the cell array of jacobian matrices (related to the geometric
            %transformation) at the integration points.
            
            %This function needs to be generalized for second and higher
            %derivatives. It could be generalized by calling gen_eval_phi
            if(~any(ders))
                vals = (element.eval_phi*Xi)';
            else
                vals = zeros(size(Xi,2),element.Neval);
                pos = find(ders);
                %if iscell(J)
                for i=1:element.Neval
                    tmp = ((J{i}) \  element.eval_dphidxi{i})';
                    vals(:,i) = (Xi'*tmp(:,pos))';
                end
                %else
                %    error('toto');
                %end
            end
        end
        
        function vals = gen_eval_phi(element,J,ders)
            %evaluates all the shape functions or their derivatives (in real space)
            %J is the cell array of jacobian matrices (related to the geometric
            %transformation) at the integration points.
            if(~any(ders))
                vals = element.eval_phi';
            else
                pos = find(ders);
                
                vals = zeros(element.Nphi,element.Neval);
                for p=1:element.Neval
                    tmp = J{p} \  element.eval_dphidxi{p};
                    %tmp = iJ{p} *  element.eval_dphidxi{p};
                    
                    vals(:,p) = tmp(pos,:)';
                    %vals(:,p) = tmp(ders,:)';
                end
            end
        end
        
        %         function result = eval_shape_functions(element,xi)
        %             result = repmat(element.fct_phi,[size(xi,1) 1]);
        %                 for ev = 1:size(xi,1)
        %                         result(ev,:) = subs(result(ev,:),element.fct_xi,xi(ev,:));
        %                 end
        %                 result = sym2double(result);
        %         end
        function result = eval_shape_functions(element,xi)
            result = zeros(size(xi,1),element.Nphi);
            for ev = 1:size(xi,1)
                loc_arg = num2cell(xi(ev,:));
                for fct = 1:element.Nphi
                    elf = element.fct_phi{fct};
                    result(ev,fct) = elf(loc_arg{:});
                end
            end
            %result = sym2double(result);
        end
        function [ok, xi] = isInElement(obj,xi)
            ok = true;
            switch obj.shape
                case 'EDGE'
                    ok =(xi(1)> -1) && (xi(1)<1);
                    if(ok); return; end;
                    if(xi<-1); xi = -1; return; end
                    if(xi>1);  xi = 1;  return; end
                case 'TRI'
                    % for the points in the negative xi plane
                    if ( xi(1)< 0 )
                        xi(1) = 0;
                        ok = false;
                        if(xi(2)>1)
                            xi(2) = 1;
                            return
                        end
                        if(xi(2)<0)
                            xi(2) = 0;
                            return
                        end
                    end
                    % for the points in the negative eta plane
                    if ( xi(2)< 0 )
                        xi(2) = 0;
                        ok = false;
                        if(xi(1)>1)
                            xi(1) = 1;
                            return
                        end
                        if(xi(1)<0)
                            xi(1) = 0;
                            return
                        end
                    end
                    % point closet to the line y = -x+1
                    
                    xi0  =  (xi(1)-xi(2)+1)/2;
                    eta0 =  (-xi(1)+xi(2)+1)/2;
                    
                    %% lower right coorner
                    if(xi0>1)
                        xi= [1 0];
                        ok = false;
                        return
                    end
                    
                    %% top left coorner
                    if(eta0>1)
                        xi= [0 1];
                        ok = false;
                        return
                    end
                    
                    if(xi0< xi(1))
                        xi = [ xi0 eta0 ];
                        ok = false;
                    end
                    
                    
                case 'QUAD'
                    if(xi(1)<-1); xi(1) = -1; ok = false; end
                    if(xi(1)> 1); xi(1) =  1; ok = false; end
                    
                    if(xi(2)<-1); xi(2) = -1; ok = false; end
                    if(xi(2)> 1); xi(2) =  1; ok = false; end
                    
                case 'HEX'
                    if(xi(1)<-1); xi(1) = -1; ok = false; end
                    if(xi(1)> 1); xi(1) =  1; ok = false; end
                    
                    if(xi(2)<-1); xi(2) = -1; ok = false; end
                    if(xi(2)> 1); xi(2) =  1; ok = false; end
                    
                    if(xi(3)<-1); xi(3) = -1; ok = false; end
                    if(xi(3)> 1); xi(3) =  1; ok = false; end
                otherwise
                    error('ELEMENT::isInElement: unsupported element shape ');
            end
        end
        function show(obj)
            
            switch obj.shape
                case 'EDGE'
                    X = linspace(-1,1,101)';
                    for i=1:obj.Nphi
                        figure;
                        h=plot(X,zeros(size(X)));
                        set(h,'color','magenta');
                        hold on
                        h=plot(obj.nodes(:,1),zeros(obj.Nphi,1),'ko');
                        set(h,'markersize',12,'markerfacecolor','black');
                        for j = 1:obj.Nphi
                            h = text(obj.nodes(j,1),0,num2str(j));
                            set(h,'fontsize',16,'fontweight','bold','color','cyan');
                        end
                        Z = arrayfun(obj.fct_phi{i},X);
                        plot(X,Z,'r','linewidth',2);
                        xlabel(obj.coords{1})
                        title(['PHI(' num2str(i) ')']);
                    end
                case 'TRI'
                    
                    [X,Y] = meshgrid(linspace(0,1,10),linspace(0,1,10));
                    XY = [X(:) Y(:)];
                    XY = XY(XY(:,1)<=1-XY(:,2),:);
                    
                    TRI = delaunay(XY(:,1),XY(:,2));
                    for i=1:obj.Nphi
                        figure;
                        h=triplot(TRI,XY(:,1),XY(:,2));
                        set(h,'color','magenta');
                        hold on
                        h=plot3(obj.nodes(:,1),obj.nodes(:,2),zeros(obj.Nphi,1),'ko');
                        set(h,'markersize',12,'markerfacecolor','black');
                        for j = 1:obj.Nphi
                            h = text(obj.nodes(j,1),obj.nodes(j,2),0,num2str(j));
                            set(h,'fontsize',16,'fontweight','bold','color','cyan');
                        end
                        Z = arrayfun(obj.fct_phi{i},XY(:,1),XY(:,2));
                        trisurf(TRI,XY(:,1),XY(:,2),Z);
                        set(gcf,'renderer','opengl');
                        view(3)
                        xlabel(obj.coords{1})
                        ylabel(obj.coords{2})
                        title(['PHI(' num2str(i) ')']);
                    end
                    
                case 'QUAD'
                    
                    [X,Y] = meshgrid(linspace(-1,1,10),linspace(-1,1,10));
                    
                    for i=1:obj.Nphi
                        figure;
                        h=mesh(X,Y,zeros(size(X)));
                        set(h,'facecolor','none','edgecolor','magenta');
                        hold on
                        Z = reshape(arrayfun(obj.fct_phi{i},X(:),Y(:)),size(X));
                        surf(X,Y,Z);
                        hold on
                        h=plot3(obj.nodes(:,1),obj.nodes(:,2),zeros(obj.Nphi,1),'ro');
                        set(h,'markersize',12,'markerfacecolor','black');
                        for j = 1:obj.Nphi
                            h = text(obj.nodes(j,1),obj.nodes(j,2),0,num2str(j));
                            set(h,'fontsize',16,'fontweight','bold','color','cyan');
                        end
                        
                        set(gcf,'renderer','opengl');
                        view(3)
                        xlabel(obj.coords{1})
                        ylabel(obj.coords{2})
                        title(['PHI(' num2str(i) ')']);
                    end
                    
                otherwise
                    error('unsupported element shape');
            end
            
        end
        
        
    end
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Protected methods
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    methods (Access=protected)
        
        function [perm] = sort_dim(arg,mode)
            %sort elements per dimensionality
            if nargin==1, mode='ascend'; end
            [~,perm] = sort([arg.dim],mode);
        end
        
        function ELEMENT = PROCESS_ELEMENT(ELEMENT)
            %Processes all the properties of the element to compute fct_phi
            %and fct_dphidxi
            ELEMENT.Nentities = size(ELEMENT.entities,1);
            assert(isscalar(ELEMENT),'Protected Method PROCESS_ELEMENT does not processes elements arrays!!');
            
            %             ELEMENT.fct_xi = SYM_ZERO(1,numel(ELEMENT.coords));
            %             for i=1:max([1 ELEMENT.dim])
            %                 ELEMENT.fct_xi(i) = SYM_COORD(ELEMENT.coords{i});
            %                 eval([ELEMENT.coords{i} '= ELEMENT.fct_xi(i);']);
            %             end
            
            %defines the coordinates in the local workspace
            my_coords = SYM_ZERO(1,numel(ELEMENT.coords));
            for i=1:max([1 ELEMENT.dim])
                my_coords(i) = SYM_COORD(ELEMENT.coords{i});
                eval([ELEMENT.coords{i} '= my_coords(i);']);
            end
            
            %             ELEMENT.fct_phi = SYM_ZERO(1,ELEMENT.Nphi);
            %             for i=1:ELEMENT.Nphi
            %                 ELEMENT.fct_phi(i) = eval(ELEMENT.phi{i});
            %             end
            
            ELEMENT.fct_phi = cell(1,ELEMENT.Nphi);
            my_fcts = SYM_ZERO(1,ELEMENT.Nphi);
            for i=1:ELEMENT.Nphi
                my_fcts(i) = eval(ELEMENT.phi{i});
                ELEMENT.fct_phi{i} = create_handle_function(my_fcts(i),my_coords);
            end
            
            %             ELEMENT.fct_dphidxi = SYM_ZERO(ELEMENT.Nphi,numel(ELEMENT.coords));
            %             for i=1:ELEMENT.Nphi
            %                 for j=1:numel(ELEMENT.coords)
            %                     ELEMENT.fct_dphidxi(i,j) = diff(ELEMENT.fct_phi(i),ELEMENT.fct_xi(j));
            %                 end
            %             end
            
            ELEMENT.fct_dphidxi = cell(ELEMENT.Nphi,numel(ELEMENT.coords));
            for i=1:ELEMENT.Nphi
                for j=1:numel(ELEMENT.coords)
                    ELEMENT.fct_dphidxi{i,j} = create_handle_function(diff(my_fcts(i),my_coords(j)),my_coords);
                end
            end
            
            
            ELEMENT.fct_d2phidxideta = cell(ELEMENT.Nphi,1);
            for i=1:ELEMENT.Nphi
                ELEMENT.fct_d2phidxideta{i} = create_handle_function(gradient(gradient(my_fcts(i),my_coords),my_coords),my_coords);
            end
        end
        
    end
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Static methods
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    methods (Static)
        %default methods for the integration points for triangles,
        %segments, squares, cubes.
        
        function [Xe,W] = point_points(~)
            Xe = 1;
            W = 1;
        end
        
        function [Xe,W] = gauss_points(dim,NP)
            %Computes the Gauss points and associated weights for a segment, square or
            %cube
            %dim: dimension 1 (segment), 2 (square), 3(cube), domain= [-1 1]^dim
            %NP : number of gauss points along each dimension. total number of points = NP^dim
            %Only implemented for  1<=NP<=3
            %Outputs:
            %Xe: matrix of size [dim^NP dim] (one line per integration point)
            %W: column vector of weights [dim^NP 1]
            %Check the inputs
            assert(ismember(dim,[1 2 3]),'dim should be 1,2 or 3');
            assert(ismember(NP,[1 2 3 4]),'Only implemented for NP=1,2,3 or 4');
            
            %gauss points for 1 dimension
            switch NP
                case 1
                    x = 0;
                    w = 2;
                case 2
                    x = [sqrt(3) -sqrt(3)]/3;
                    w = [1 1];
                case 3
                    x = [sqrt(3/5) 0.0 -sqrt(3/5)];
                    w = [5/9 8/9  5/9];
                case 4
                    x = [sqrt(3/7 - 2/7*sqrt(6/5)) -sqrt(3/7 - 2/7*sqrt(6/5)) sqrt(3/7 + 2/7*sqrt(6/5)) -sqrt(3/7 + 2/7*sqrt(6/5)) ];
                    w = [(18+sqrt(30))/36 (18+sqrt(30))/36 (18-sqrt(30))/36 (18-sqrt(30))/36 ];
            end
            % constructs all the NP^dim combinations
            switch dim
                case 1
                    Xe = x;
                    W = w;
                case 2
                    [a,b] = ind2sub([length(x) length(x)],1:(length(x))^2);
                    Xe = [x(a);x(b)];
                    W = w(a).*w(b);
                case 3
                    [a,b,c] = ind2sub([length(x) length(x) length(x)],1:(length(x))^3);
                    Xe = [x(a);x(b);x(c)];
                    W = w(a).*w(b).*w(c);
            end
            Xe = Xe';
        end
        function [Xe,W] = hammer_points(NP)
            %position des points d'int�gration de hammer
            switch NP
                case 1
                    Xe = [1;1]'/3;
                    W = 0.5;
                case 2
                    Xe = [0.5 0.5 0 ; 0 0.5 0.5]';
                    W = [1 1 1]/6;
                case 3
                    Xe = [1/3 1/5 3/5 1/5 ; 1/3 3/5 1/5 1/5]';
                    W = [-9/32 25/96 25/96 25/96];
                otherwise
                    error('Unsupported value of NP');
            end
        end
        
        function [Xe,W] = tet_points(NP)
            %position des points d'int�gration de hammer
            % from http://www.mems.rice.edu/~akin/Elsevier/Chap_10.pdf
            switch NP
                case 1
                    Xe = [1;1;1]'/4;
                    W = 1/6;
                case 2
                    a = ( 5 + 3*sqrt(5) )/20;
                    b = ( 5 - 3*sqrt(5) )/20;
                    Xe = [a b b b; b a b b ; b b a b]';
                    W = [1 1 1 1]/24;
                case 3
                    Xe = [1/4 1/2 1/6 1/6 1/6; 1/4 1/6 1/2 1/6 1/6; 1/4 1/6 1/6 1/2 1/6]';
                    W = [-4/30 9/120 9/120 9/120 9/120];
                case 4
                    a = ( 1 + sqrt(5/14))/4;
                    b = ( 1 - sqrt(5/14))/4;
                    Xe = [1/4 11/14 1/14 1/14 1/14 a a a b b b
                        1/4 1/14 11/14 1/14 1/14 a b b a a b
                        1/4 1/14 1/14 11/14 1/14 b a b a b a]';
                    c = 343/45000;
                    d = 56/2250;
                    W = [-74/5625 c c c c d d d d d d];
                otherwise
                    error('Unsupported value of NP');
            end
        end
        
        function id = diff_id(diff_symbol)
            assert(sum(diff_symbol)<=1,'Higher derivatives not supported');
            if any(diff_symbol)
                id = find(diff_symbol)+1;
            else
                id=1;
            end
        end
        
        
    end
end
